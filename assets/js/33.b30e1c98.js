(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{325:function(v,_,t){"use strict";t.r(_);var e=t(28),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"简单讲解一下-http2-的多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单讲解一下-http2-的多路复用"}},[v._v("#")]),v._v(" ❓简单讲解一下 http2 的多路复用")]),v._v(" "),t("p",[v._v("还是要介绍一下，http 多个请求发展史的。")]),v._v(" "),t("p",[v._v("多个 TCP 链接 -> keep-alive -> 管线化（pipe-line）-> 多路复用")]),v._v(" "),t("h3",{attrs:{id:"多个-tcp-链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个-tcp-链接"}},[v._v("#")]),v._v(" 多个 TCP 链接")]),v._v(" "),t("p",[v._v("最初的时候要想做多次请求，只能建立多个 TCP 链接来实现通信，一次请求完成之后就会关闭本次 TCP 链接，下次链接又要重新建立 TCP 链接，重复链接动作。\n这回带来很大性能损耗。")]),v._v(" "),t("h3",{attrs:{id:"keep-alive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[v._v("#")]),v._v(" keep-alive")]),v._v(" "),t("p",[v._v("一定时间内（可以配置），同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。\n以往，浏览器判断响应数据是否接收完毕，是看连接是否关闭。在使用持久连接后，就不能这样了，这就要求服务器对持久连接的响应头部一定要返回 "),t("code",[v._v("content-length")]),v._v(" 标识 "),t("code",[v._v("body")]),v._v(" 的长度，供浏览器判断界限。有时，"),t("code",[v._v("content-length")]),v._v(" 的方法并不是太准确，也可以使用 "),t("code",[v._v("Transfer-Encoding: chunked")]),v._v(" 头部发送一串一串的数据，最后由长度为 0 的 "),t("code",[v._v("chunked")]),v._v(" 标识结束。")]),v._v(" "),t("p",[v._v("但是还是存在问题")]),v._v(" "),t("ul",[t("li",[v._v("串行的文件传输")]),v._v(" "),t("li",[v._v("同域并行请求限制带来的阻塞（6~8）个")])]),v._v(" "),t("h3",{attrs:{id:"管线化（pipe-line）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管线化（pipe-line）"}},[v._v("#")]),v._v(" 管线化（pipe-line）")]),v._v(" "),t("p",[v._v("可以克服"),t("code",[v._v("同域并行请求限制带来的阻塞")]),v._v("，它是建立在"),t("strong",[v._v("持久连接")]),v._v("之上，是把所有请求一并发给服务器，但是服务器需要"),t("strong",[v._v("按照顺序一个一个响应")]),v._v("，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。不过，HTTP 管线化仍旧有阻塞的问题，"),t("strong",[v._v("若上一响应迟迟不回，后面的响应都会被阻塞到")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[v._v("#")]),v._v(" 多路复用")]),v._v(" "),t("p",[v._v("代替原来的"),t("code",[v._v("序列")]),v._v("和"),t("code",[v._v("阻塞机制")]),v._v("。所有就是请求的都是通过一个 "),t("code",[v._v("TCP")]),v._v(" 连接并发完成。因为在多路复用之前所有的传输是基于"),t("strong",[v._v("文本")]),v._v("（所有的数据必须按顺序传输，比如需要传输："),t("code",[v._v("hello world")]),v._v("，只能从 "),t("code",[v._v("h")]),v._v(" 到 "),t("code",[v._v("d")]),v._v(" 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 "),t("code",[v._v("HTTP1.1")]),v._v(" 是不能实现的。）的。多路复用中是基于"),t("strong",[v._v("二进制数据帧")]),v._v("的传输、消息、流，所以可以做到"),t("strong",[v._v("乱序")]),v._v("的传输。多路复用对同一域名下所有请求都是基于"),t("strong",[v._v("流")]),v._v("，所以不存在同域并行的阻塞。")]),v._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("在 HTTP/2 中，有两个非常重要的概念，分别是"),t("strong",[v._v("帧（frame）"),t("strong",[v._v("和")]),v._v("流（stream）")]),v._v("。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("帧 代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。")])]),v._v(" "),t("li",[t("p",[v._v("HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);