## :question:介绍下深度优先遍历和广度优先遍历，如何实现？

这道题目对于没怎么接触算法的童鞋来说肯定是十脸懵逼的。当然我对于我来说---也是一样的:joy:。

所以说去查阅了一些资料，以及看了大多数童鞋的解答。

整理如下：

|              | 定义                                                                                                                                 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------ |
| 深度优先遍历 | 如下面假设的对象，我们从 root 开始向下遍历，依次从所有未访问子元素中**深度优先遍历**直到最终子元素，如果还有相邻元素未遍历就以此类推 |

---

```js
// 假设我们有一对象
const TreeRoot = [
  {
    value: "A",
    children: [
      { value: "A-a", children: [{ value: "A-a-1" }, { value: "A-a-2" }] },
      { value: "A-b", children: [{ value: "A-b-1" }, { value: "A-b-2" }] }
    ]
  },
  {
    value: "B",
    children: [
      { value: "B-a", children: [{ value: "B-a-1" }, { value: "B-a-2" }] },
      { value: "B-b", children: [{ value: "B-b-1" }, { value: "B-b-2" }] }
    ]
  },
  {
    value: "C",
    children: [
      { value: "C-a", children: [{ value: "C-a-1" }, { value: "C-a-2" }] },
      { value: "C-b", children: [{ value: "C-b-1" }, { value: "C-b-2" }] }
    ]
  }
];
```

[图]

## 深度优先遍历

```js
// 递归实现
function myDfs1(root) {
  const result = []; // 存放最终结果
  // 闭包 递归方法
  const dfs = target => {
    // 遍历节点
    target.forEach(element => {
      if (element.value) {
        // 存放当前节点值
        result.push(element.value);
        // 检测字节点
        if (element.children && element.children.length > 0) {
          // 递归字节点
          dfs(element.children);
        }
      }
    });
  };

  dfs(root);
  return result;
}

const myDfs1Result = myDfs1(TreeRoot);
console.log(myDfs1Result);

// 非递归实现
function myDfs2(root) {
  const result = []; // 存放最终返回
  const stack = []; // 存放遍历对象

  if (root) {
    stack.push(...root); // 推入处理对象
    while (stack.length) {
      const element = stack.shift();
      result.push(element.value);
      const children = element.children;
      if (children && children.length > 0) {
        for (let index = 0; index < children.length; index++) {
          stack.unshift(children[index]);
        }
      }
    }
  }

  return result;
}

const myDfs2Result = myDfs2(TreeRoot);
console.log(myDfs2Result);

// 最终的结果都是一样的
// [ 'A',
//   'A-a',
//   'A-a-1',
//   'A-a-2',
//   'A-b',
//   'A-b-1',
//   'A-b-2',
//   'B',
//   'B-a',
//   'B-a-1',
//   'B-a-2',
//   'B-b',
//   'B-b-1',
//   'B-b-2',
//   'C',
//   'C-a',
//   'C-a-1',
//   'C-a-2',
//   'C-b',
//   'C-b-1',
//   'C-b-2' ]
```

## 广度优先遍历
