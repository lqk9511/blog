(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{373:function(t,a,s){"use strict";s.r(a);var e=s(28),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"call-和-apply-的区别是什么，哪个性能更好一些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-和-apply-的区别是什么，哪个性能更好一些"}},[t._v("#")]),t._v(" ❓ call 和 apply 的区别是什么，哪个性能更好一些")]),t._v(" "),s("p",[t._v("两者的作用是相同的。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("第一个参数都是，指定函数体内 "),s("code",[t._v("this")]),t._v(" 的指向")])]),t._v(" "),s("li",[s("p",[t._v("第二个参数开始不同 "),s("code",[t._v("apply")]),t._v(" 是传入带下标的集合，数组或者类数组，"),s("code",[t._v("apply")]),t._v(" 把它传给函数作为参数，"),s("code",[t._v("call")]),t._v(" 从第二个开始传入的参数是不固定的，都会传给函数作为参数。")])])]),t._v(" "),s("p",[s("code",[t._v("call")]),t._v(" 的性能是比 "),s("code",[t._v("apply")]),t._v(" 的性能要好一些的")]),t._v(" "),s("blockquote",[s("p",[t._v("apply 多了 "),s("code",[t._v("CreateListFromArrayLike")]),t._v(" 的调用，其他的操作几乎是一样的（甚至 "),s("code",[t._v("apply")]),t._v(" 仍然多了点操作）。从草案的算法描述来看，call 性能 > apply 性能。")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84#issuecomment-599313971",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84#issuecomment-599313971"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("尤其是 ES6 引入了 Spread operator (延展操作符) 后，即使参数是数组，可以使用 call")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" params "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("xx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("params"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("在我们平时的开发中可以尽可能的去用 "),s("code",[t._v("call")]),t._v("，特别是 ES6 的 reset 解构的支持，"),s("code",[t._v("call")]),t._v(" 基本可以代替 "),s("code",[t._v("apply")])]),t._v(" "),s("p",[t._v("lodash 源码里面并没有直接用 Function.prototype.apply，而是在参数较少（1-3）个时采用 "),s("code",[t._v("call")]),t._v(" 的方式调用")]),t._v(" "),s("p",[t._v("lodash 里面没有超过 4 个参数的方法，PS 如果一个函数的设计超过 4 个入参，那么这个函数就要考虑重构的问题了。")])])}),[],!1,null,null,null);a.default=n.exports}}]);