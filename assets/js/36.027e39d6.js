(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{326:function(t,e,s){"use strict";s.r(e);var a=s(28),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"react-中-setstate-什么时候是同步的，什么时候是异步的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-中-setstate-什么时候是同步的，什么时候是异步的？"}},[t._v("#")]),t._v(" ❓React 中 setState 什么时候是同步的，什么时候是异步的？")]),t._v(" "),s("p",[s("strong",[t._v("注意")])]),t._v(" "),s("p",[t._v("这里所说的同步异步， 并不是真正的同步异步， 它还是同步执行的。")]),t._v(" "),s("p",[t._v("这里的异步指的是多个 state 会合成到一起进行批量更新。（不要被误导哦）")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。")])])}),[],!1,null,null,null);e.default=n.exports}}]);