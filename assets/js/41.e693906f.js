(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{335:function(v,_,t){"use strict";t.r(_);var e=t(28),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"介绍下重绘和重排（repaint-reflow），以及如何进行优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍下重绘和重排（repaint-reflow），以及如何进行优化"}},[v._v("#")]),v._v(" ❓介绍下重绘和重排（Repaint & Reflow），以及如何进行优化")]),v._v(" "),t("p",[v._v("这个题目牵扯到浏览器的渲染机制")]),v._v(" "),t("h3",{attrs:{id:"浏览器的渲染机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染机制"}},[v._v("#")]),v._v(" 浏览器的渲染机制")]),v._v(" "),t("ol",[t("li",[v._v("处理 HTML 标记并构建 DOM 树")]),v._v(" "),t("li",[v._v("处理 CSS 标记并构建 CSSOM 树")]),v._v(" "),t("li",[v._v("将 DOM 与 CSSOM 合并成一个渲染树")]),v._v(" "),t("li",[v._v("根据渲染树来布局，以计算每个节点的几何信息")]),v._v(" "),t("li",[v._v("将各个节点绘制到屏幕上")])]),v._v(" "),t("p",[t("strong",[v._v("优化关键渲染路径就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间")]),v._v("。 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。")]),v._v(" "),t("p",[v._v("来自于"),t("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[v._v("MDN"),t("OutboundLink")],1)]),v._v(" "),t("h3",{attrs:{id:"重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[v._v("#")]),v._v(" 重绘")]),v._v(" "),t("p",[v._v("由于节点的几何属性或者样式属性发生变化而不影响布局的，称为重绘。比如："),t("code",[v._v("outline")]),v._v("，"),t("code",[v._v("visibility")]),v._v("，"),t("code",[v._v("color")]),v._v("，"),t("code",[v._v("background-color")]),v._v("等。同时浏览器也会重新验证其他节点的可见性。")]),v._v(" "),t("h3",{attrs:{id:"重排（回流）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重排（回流）"}},[v._v("#")]),v._v(" 重排（回流）")]),v._v(" "),t("p",[v._v("节点的几何属性发生变化，影响布局，称之为重排。"),t("strong",[v._v("重绘不一定重排，重排一定重绘")]),v._v("。重排是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的重排可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的重排。")]),v._v(" "),t("h3",{attrs:{id:"那么什么操作会引发重排重绘呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么什么操作会引发重排重绘呢"}},[v._v("#")]),v._v(" 那么什么操作会引发重排重绘呢")]),v._v(" "),t("ul",[t("li",[v._v("添加或删除可见的 DOM 元素")]),v._v(" "),t("li",[v._v("元素的位置发生变化")]),v._v(" "),t("li",[v._v("元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）")]),v._v(" "),t("li",[v._v("内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。")]),v._v(" "),t("li",[v._v("页面一开始渲染的时候（这肯定避免不了）")]),v._v(" "),t("li",[v._v("浏览器的窗口尺寸变化（因为重排是根据视口的大小来计算元素的位置和大小的）")])]),v._v(" "),t("h3",{attrs:{id:"浏览器优化机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器优化机制"}},[v._v("#")]),v._v(" 浏览器优化机制")]),v._v(" "),t("p",[v._v("由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！"),t("strong",[v._v("当你获取布局信息的操作的时候，会强制队列刷新")]),v._v("，比如当你访问以下属性或者使用以下方法：")]),v._v(" "),t("p",[t("code",[v._v("offsetTop")]),v._v("、"),t("code",[v._v("offsetLeft")]),v._v("、"),t("code",[v._v("offsetWidth")]),v._v("、"),t("code",[v._v("offsetHeight")])]),v._v(" "),t("p",[t("code",[v._v("scrollTop")]),v._v("、"),t("code",[v._v("scrollLeft")]),v._v("、"),t("code",[v._v("scrollWidth")]),v._v("、"),t("code",[v._v("scrollHeight")])]),v._v(" "),t("p",[t("code",[v._v("clientTop")]),v._v("、"),t("code",[v._v("clientLeft")]),v._v("、"),t("code",[v._v("clientWidth")]),v._v("、"),t("code",[v._v("clientHeight")])]),v._v(" "),t("p",[t("code",[v._v("getComputedStyle()")]),v._v(" "),t("code",[v._v("getBoundingClientRect")])]),v._v(" "),t("p",[v._v("具体可以访问这个网站："),t("a",{attrs:{href:"https://gist.github.com/paulirish/5d52fb081b3570c81e3a",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://gist.github.com/paulirish/5d52fb081b3570c81e3a"),t("OutboundLink")],1)]),v._v(" "),t("p",[v._v("以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发重排重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来")]),v._v(" "),t("h3",{attrs:{id:"减少重排与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减少重排与重绘"}},[v._v("#")]),v._v(" 减少重排与重绘")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("css")]),v._v(" "),t("ul",[t("li",[v._v("使用 "),t("code",[v._v("transform")]),v._v(" 替代 "),t("code",[v._v("top")])]),v._v(" "),t("li",[v._v("使用 "),t("code",[v._v("visibility")]),v._v(" 替换 "),t("code",[v._v("display: none")]),v._v(" ，因为前者只会引起重绘，后者会引发重排")]),v._v(" "),t("li",[v._v("避免使用 "),t("code",[v._v("table")]),v._v(" "),t("code",[v._v("布局，table")]),v._v(" 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间")]),v._v(" "),t("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁重排")]),v._v(" "),t("li",[v._v("css3 硬件加速（GPU 加速）可以让 transform、opacity、filters 这些动画不会引起重排重绘。对于动画的其它属性，比如 background-color 这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。常见的触发硬件加速的 css 属性："),t("code",[v._v("transform")]),v._v("，"),t("code",[v._v("opacity")]),v._v("，"),t("code",[v._v("filters")]),v._v("， "),t("code",[v._v("Will-change")])])])]),v._v(" "),t("li",[t("p",[v._v("javascript")]),v._v(" "),t("ul",[t("li",[v._v("合并相关样式操作，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。")]),v._v(" "),t("li",[v._v("避免频繁的 DOM 操作，或者创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。")]),v._v(" "),t("li",[v._v("避免频繁读取会引发重排/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")])])])])])}),[],!1,null,null,null);_.default=r.exports}}]);