(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{300:function(s,t,a){"use strict";a.r(t);var n=a(28),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"var、let-和-const-区别的实现原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var、let-和-const-区别的实现原理是什么"}},[s._v("#")]),s._v(" ❓ var、let 和 const 区别的实现原理是什么")]),s._v(" "),a("h2",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[s._v("#")]),s._v(" 区别")]),s._v(" "),a("h3",{attrs:{id:"var"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[s._v("#")]),s._v(" var")]),s._v(" "),a("p",[s._v("var 声明的变量，不存在块级作用域，在全局范围内都有效（顶层变量）")]),s._v(" "),a("p",[s._v("变量提升")]),s._v(" "),a("p",[s._v("内层变量可能覆盖外层变量")]),s._v(" "),a("p",[s._v("用来计数的循环变量泄露为全局变量")]),s._v(" "),a("h3",{attrs:{id:"let"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[s._v("#")]),s._v(" let")]),s._v(" "),a("ul",[a("li",[a("p",[a("code",[s._v("let")]),s._v(" 声明块级作用域变量")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("不存在变量提升")])])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// var 的情况")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 输出undefined")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// let 的情况")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 报错ReferenceError")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("ul",[a("li",[s._v("暂时性死区")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" tmp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  tmp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ReferenceError")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" tmp\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("上面代码中，存在全局变量 "),a("code",[s._v("tmp")]),s._v("，但是块级作用域内 "),a("code",[s._v("let")]),s._v(" 又声明了一个局部变量 "),a("code",[s._v("tmp")]),s._v("，导致后者绑定这个块级作用域，所以在 "),a("code",[s._v("let")]),s._v(" 声明变量前，对 "),a("code",[s._v("tmp")]),s._v(" 赋值会报错。")]),s._v(" "),a("p",[s._v("ES6 明确规定，如果区块中存在 "),a("code",[s._v("let")]),s._v(" 和 "),a("code",[s._v("const")]),s._v(" 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。")]),s._v(" "),a("p",[s._v("总之，在代码块内，使用 "),a("code",[s._v("let")]),s._v(" 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。")]),s._v(" "),a("ul",[a("li",[s._v("不允许重复声明")])]),s._v(" "),a("p",[a("code",[s._v("let")]),s._v(" 不允许在相同作用域内，重复声明同一个变量。")]),s._v(" "),a("h3",{attrs:{id:"const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[s._v("#")]),s._v(" const")]),s._v(" "),a("p",[a("code",[s._v("const")]),s._v(" 声明一个只读的常量。一旦声明，常量的值就不能改变。")]),s._v(" "),a("p",[a("code",[s._v("const")]),s._v(" 声明的变量不得改变值，这意味着，"),a("code",[s._v("const")]),s._v(" 一旦声明变量，就必须立即初始化，不能留到以后赋值。")]),s._v(" "),a("p",[a("code",[s._v("const")]),s._v(" 声明的常量，也与 "),a("code",[s._v("let")]),s._v(" 一样不可重复声明。")]),s._v(" "),a("p",[a("code",[s._v("const")]),s._v(" 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。")]),s._v(" "),a("h4",{attrs:{id:"本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本质"}},[s._v("#")]),s._v(" 本质")]),s._v(" "),a("p",[a("code",[s._v("const")]),s._v(" 实际上保证的，并不是变量的值不得改动，而是变量指向的那个"),a("strong",[s._v("内存地址所保存的数据")]),s._v("不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 为 foo 添加一个属性，可以成功")]),s._v("\nfoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prop "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v("\nfoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prop "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 123")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 将 foo 指向另一个对象，就会报错")]),s._v("\nfoo "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v('// TypeError: "foo" is read-only')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("上面代码中，常量 "),a("code",[s._v("foo")]),s._v(" 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 "),a("code",[s._v("foo")]),s._v(" 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。")]),s._v(" "),a("p",[a("strong",[a("code",[s._v("var")]),s._v(" 命令和 "),a("code",[s._v("function")]),s._v(" 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，"),a("code",[s._v("let")]),s._v(" 命令、"),a("code",[s._v("const")]),s._v(" 命令、"),a("code",[s._v("class")]),s._v(" 命令声明的全局变量，不属于顶层对象的属性。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);