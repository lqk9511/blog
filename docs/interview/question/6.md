## :question:请分别用深度优先思想和广度优先思想实现一个拷贝函数？

这道题目刚刚好跟我们上面的一道关联性很强，经过上面的深度广度优先遍历我们知道了它们的遍历思想。那么结合这道题目。

假设我们有一个目标对象：

```js
const testTarget = {
  name: "jeff",
  tree: {
    value: "root",
    children: [
      {
        value: "A",
        children: [
          { value: "A-a", children: [{ value: "A-a-1" }, { value: "A-a-2" }] },
          { value: "A-b", children: [{ value: "A-b-1" }, { value: "A-b-2" }] }
        ]
      },
      {
        value: "B",
        children: [
          { value: "B-a", children: [{ value: "B-a-1" }, { value: "B-a-2" }] },
          { value: "B-b", children: [{ value: "B-b-1" }, { value: "B-b-2" }] }
        ]
      },
      {
        value: "C",
        children: [
          { value: "C-a", children: [{ value: "C-a-1" }, { value: "C-a-2" }] },
          { value: "C-b", children: [{ value: "C-b-1" }, { value: "C-b-2" }] }
        ]
      }
    ]
  },
  deepQuote: null
};
```

```js
// 辅助函数
const typeMap = {
  array: "Array",
  object: "Object",
  function: "Function",
  string: "String",
  null: "Null",
  undefined: "Undefined",
  boolean: "Boolean",
  number: "Number"
};
const isTypeof = (obj, type) =>
  Object.prototype.toString.call(obj).slice(8, -1) === typeMap[type];
```

```js
// 如果有循环引用的关系，就是环形引用
// testTarget.deepQuote = testTarget;

// 深度优先思想
// 第二个参数解决循环引用
function dfsDeepClone(target, verifyArr = []) {
  let result = null;

  if (isTypeof(target, "object")) {
    result = {};
    for (const key in target) {
      if (target.hasOwnProperty(key)) {
        const element = target[key];
        // console.log(element);
        // 验证是否遍历过这个对象
        if (verifyArr.includes(element)) {
          result[key] = element;
        } else {
          verifyArr.push(element);
          // 这里记得把 verifyArr 数组调用时候带入
          result[key] = dfsDeepClone(element, verifyArr);
        }
      }
    }
  } else if (isTypeof(target, "array")) {
    result = [];
    for (let index = 0; index < target.length; index++) {
      const element = target[index];
      // console.log(element);
      // 验证是否遍历过这个对象
      if (verifyArr.includes(element)) {
        result.push(element);
      } else {
        verifyArr.push(element);
        // 这里记得把 verifyArr 数组调用时候带入
        result.push(dfsDeepClone(element, verifyArr));
      }
    }
  } else if (isTypeof(target, "function")) {
    result = Function(
      `"use strict"; return (function() {return ${target.toString()}})`
    );
  } else {
    result = target;
  }

  return result;
}

const dfsDeepCloneResult = dfsDeepClone(testTarget);
// 如果把上面的循环引用打开的话，这里会报错
// Converting circular structure to JSON
console.log(JSON.stringify(dfsDeepCloneResult));
// 这里的结果我就不展示了。
// 有兴趣可以去跑一下 https://github.com/lqk9511/blog/blob/master/docs/interview/test/6.js
```

[/test/6.js](https://github.com/lqk9511/blog/blob/master/docs/interview/test/6.js)
